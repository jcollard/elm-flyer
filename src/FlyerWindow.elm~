module FlyerWindow where

import open Flyer
import open Graphics.Location
import Graphics.Collage as Collage
import Window
import Signal
import Mouse

data Event 
 = FPS Time 
 | Click (Int, Int)
 | Display (Int, Int) 

clickEvents : Signal Event
clickEvents = Click <~ Signal.sampleOn Mouse.clicks Mouse.position

tickEvents : Signal Event
tickEvents = FPS <~ fps 32

displayEvent : Signal Event
displayEvent = Display <~ Window.dimensions

allEvents : Signal Event
allEvents = merges [displayEvent, clickEvents, tickEvents]

startFlyer : Flyer
startFlyer = { location = loc (0, 0), orientation = 0 }

scene state =
  let background = 
        Collage.filled black <| 
        Collage.rect state.displayWidth state.displayHeight
      details = asText state
      flyer = drawFlyer <| transform state
  in
   flow down [
  Collage.collage (round state.displayWidth) (round state.displayHeight)
                  [background, flyer],
  details]

initialState = { flyer = startFlyer
               , animations = []
               , time = 0
               , displayWidth = 400
               , displayHeight = 400
               }

runEvent event state =
  case event of
    FPS frames -> handleState {state| time <- state.time + frames }
    Click coord -> if state.time > 0 then handleClick (toLoc state coord) state
                      else state
    Display (width, height) -> {state| displayWidth <- width, displayHeight <- height}

toLoc state (left, top) =    
  let left' = toFloat <| left - (state.displayWidth `div` 2)
      top' = toFloat <| (state.displayHeight `div` 2) - top
  in loc (left', top')

handleState state = 
  case state.animations of
    [] -> state
    anims -> 
      let (flyer, animations) = clearAnims state
      in {state| flyer <- flyer, animations <- animations}

clearAnims state = clearAnims' [] state.time state.flyer state.animations

clearAnims' acc time flyer ts =
  case ts of
    [] -> (flyer, acc)
    (t::ts) -> 
      if time > t.finished then clearAnims' acc time (t.animation flyer time) ts
      else clearAnims' (t::acc) time flyer ts

transform state = transform' state.time state.flyer state.animations

transform' time flyer ts =
  case ts of
    [] -> flyer
    (t::ts) -> 
      let trans = (t.animation flyer time)
      in transform' time trans ts

finalTransform state = finalTransform' state.flyer state.animations
finalTransform' flyer ts =
  case ts of
    [] -> flyer
    (t::ts) -> finalTransform' (t.animation flyer t.finished) ts

handleClick location state = 
  let flyer' = finalTransform state
      record = flyerRecord location flyer' state.time
  in {state| animations <- record::state.animations}

main = scene <~ (foldp runEvent initialState allEvents)